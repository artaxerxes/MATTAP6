%----- MatTAP Toolbox Function -----
% Copyright 2007, 2008, 2009. University of Birmingham, UK.
%
% DAQ driver function for use with MatTAP
% M. T. Elliott, 2007, 2008
% v4_50 accept and report to soundcard and record keyboard.
% Special version: dblCh: outputs sync pulses for both metronome channels

function [inputdata, int_hw, return_structure] = DAQ_inout_v5_20(data, SampleRate)

% Inputs:
% data - metronome output vector generated by tool, consists of XtwoX
% -three- columns; first is metronome 1 sync pulses, second is ch1 audio tones, third is metronome 2 sync pulses, fourth is channel 2 tones.
% SampleRate: Sampling Rate for output.


% Output: two channels of captured data, first channel is sync pulse input,
% second channel is tap data etc.

% int_hw legend
% NIDAQ = 0
% internal hardware with keyboard = 1
% internal hardware with loopback to mic = 2

%return_structure - returns actual Fs for AO and AI winsoubd which can vary
%madly!  consider that the MATTAP assumes a Fs and we may broadcasdt at
%another - so that should be a breakable offence if there is a mismatch

%% INI File
%demo_check = strfind(mfilename('fullfile'), 'DEMO') % check whether the local filename (or any element of the path is DEMO

return_structure = []; %not implemented yet
warning('off', 'MATLAB:dispatcher:ShadowedMEXExtension'); %switch off mex warning for PTB functions

matfile = 'mattap_v6_01'; % the file name of mattap used to call this function
matpath = which(matfile); %find path that mattap is in
k = strfind(matpath, matfile); %find and remove filename from path

ini_path = matpath(1:k(end)-1); %use last index in case filename is used in path name
ini_file = 'mattap.ini';
ini_fullfile = fullfile(ini_path, ini_file);
try
    if (exist(ini_fullfile, 'file'))
        ini_opts = fetchIniData(ini_fullfile, 'section','OPTIONS');
        
        if ~strcmp(ini_opts.OPTIONS, 'Section not found')
            int_hw = str2double(ini_opts.OPTIONS.Internal_Hardware);
        else
            int_hw = 0; % i.e. NIDAQ
        end
        
        
        if ~int_hw %use DAQ 
            try
                ini_daq = fetchIniData(ini_fullfile,'section','DAQ');   %use FetchIniData to read ini file (from Matlab Central)
                adaptor = ini_daq.DAQ.Adaptor;  %DAQ Adaptor name
                dev = ini_daq.DAQ.Device;
                NumCh = str2double(ini_daq.DAQ.NumChannelsIn);  %Number of input channels
                in_ch = 0:NumCh-1; %Assign channel numbers.
                
                in_type = ini_daq.DAQ.InputType;    %DAQ Signal type (e.g. SingleEnded, Differential)
                in_rng = [str2double(ini_daq.DAQ.InputRangeLow), str2double(ini_daq.DAQ.InputRangeHigh)]; %Sensor voltage range
                out_rng = [str2double(ini_daq.DAQ.OutputRangeLow), str2double(ini_daq.DAQ.OutputRangeHigh)]; %Stimulus voltage range
            catch
                uiwait(warndlg('DAQ info not found in .ini file, using internal hardware + keyboard', 'warn', 'modal'));
                int_hw = 1;
            end
        end
    else
        
        
        uiwait(warndlg('.ini file not found, using internal hardware + keyboard', 'warn', 'modal'));
        
        %disp('.ini file not found, using internal hardware');
        int_hw=1; %NO ini - use internal hardware.
        
    end
    
catch
    uiwait(errordlg('Error reading .ini file, internal hardware (demo) mode selected', 'Error', 'modal'));
    int_hw =1;
end

if int_hw ==1
    % For some laptops ignore Key 13
    %
    if exist('ini_opts')
        ignore_return = DisableKeysForKbCheck(str2num(ini_opts.OPTIONS.Keyboard_Mask));
    end
    % EVERYTHING WE CAN SHOVE BEFORE THE WAVPLAY, SO NOTHING LIES BETWEEN
    % IT AND KbCheck
    
    %   KbCheck is a MEX files, which takes time to load when
    %   first called. It'll then stay loaded until you flush them (e.g. by
    %   changing directory or calling CLEAR MEX).
    [ keyIsDown, timeSecs, keyCode ] = KbCheck; % pre-load KbCheck into memory!
    
    % arbitary choice of max 100 keypresses
    recovered_keypresses = zeros(100,1);
    keycount = 0;
    duration = length(data)/SampleRate;
    
    %
    wavplay(data(:,2)+data(:,4), SampleRate, 'async');
    %audiplayer(data(:,2)+data(:,4), SampleRate, 'async');
    
    % beware sampling rate
    
    % KEY BOARD
    startSecs = GetSecs;
    timeSecs = startSecs;
    while (duration> (timeSecs - startSecs))
        [ keyIsDown, timeSecs, keyCode ] = KbCheck;
        if keyIsDown
            keycount = keycount +1;
            
            recovered_keypresses(keycount) = timeSecs - startSecs;
            
            % If the user holds down a key, KbCheck will report multiple events.
            % To condense multiple 'keyDown' events into a single event, we wait until all
            % keys have been released.
            while KbCheck; end
        end
    end
    
    %now inflate recovered_keypresses to be the same output we expected from DAQ_
    % input_data = recovered keypresses of duration X
    % expected output sample rate SampleRate
    output_fs = SampleRate;
    output_samples = ceil(duration * output_fs);
    keypress_length = 100; %fiddle factor to make sure the code aftwards picks up[ these keypresses
    keypress_value = 5; % 5 volts keypress
    inflated_keypresses = zeros(output_samples, 1);
    [x,y,recovered_keypresses] = find(recovered_keypresses);
    for iterations = 1 : length(recovered_keypresses)
        inserts = ceil((recovered_keypresses(iterations)) *output_fs);
        
        inflated_keypresses(inserts:inserts+keypress_length) =  keypress_value;
        
        %         inflated_keypresses(round((recovered_keypresses(iterations))*output_fs)...
        %             :(round(recovered_keypresses(iterations)+keypress_length)*output_fs)) = ...
        %             keypress_value;
    end
    
    %% this line assumes one to one correspondance of output to input
    inputdata =  [data(:,2) , inflated_keypresses(1:length(data(:,2)))];
    
    
    %Otherwise - back to DAQ!
elseif (int_hw == 0)
    %% Create analogue input object
    ai = analoginput(adaptor, dev); %Set this appropriate to your DAQ device.
    in_chan = addchannel(ai,in_ch); % input channels
    set(ai,'SampleRate', SampleRate); %input sample rate
    set(ai, 'InputType', in_type); %input type: e.g Single Ended.
    set(in_chan, 'InputRange', in_rng); %input voltage range (0-10V)
    
    set(ai,'SamplesPerTrigger', length(data)); %Number of samples to capture.
    set(ai,'TriggerType','Manual'); %Trigger type
    
    %    create digital output for triggering APDM - this is hardwired -
    dio = digitalio(adaptor, dev);
    addline(dio,0:1,'out');
    %putvalue(dio, [4 4]); % twin lines - though we might need only one -
    %we will use the other for verification by hotwiring it to channel 0?
    
    %% Open the analog output device and channels
    ao = analogoutput(adaptor, dev); %NI device
    ao_chans = 0:size(data,2)-1; %number of channels based on data matrix
    chan = addchannel(ao, ao_chans); %output channels %Changed for dblCh
    set(chan, 'OutputRange', out_rng); %output voltage range
    
    set(ao,'SampleRate',SampleRate); %set the sampling rate
    set(ao,'TriggerType','Manual'); %set the trigger type
    
    %% Put the data in the buffer, start the device, and trigger
    putdata(ao,data)
    start(ai)
    start(ao)
    trigger(ao)
    trigger(ai)
    putvalue(dio, [4 4]); % twin lines
    %% clean up, close down
    
    inputdata = getdata(ai);
    putvalue(dio, [0 0]); % twin lines - capture will align only at the beginning
    delete(ai)
    clear ai
    delete(ao)
    clear ao
    delete(dio)
    clear dio
    
elseif (int_hw == 2)  % LOOPBACK MIC TO INTERNAL SOUNDCARD
    
    
    %data = data(:,[3 1]); % force data to have only 2 channels - we assume the first channel is sync pulses, and the second the actual audio
    %this line was required when data was a x,4 array of
    % [audio blank sync blank]
    %
    %    Suggested frequency 22.XkHz?
    %     % SOUND CARD DAQ!
    %
    %     AO = analogoutput('winsound');
    %     %Add channels — Add one channel to AO.
    %     addchannel(AO,1);
    %     set(AO,'SampleRate',SampleRate)
    %     set(AO,'TriggerType','Manual');
    %     ActualRate = get(AO,'SampleRate'); %occasionally auto selects a
    %     differing one to fit avialable options
    %     duration = length(data)/ActualRate;
    %     putdata(AO,data(2,:)); %check the orientation
    %     delete(AO);
    
   
    
    %assume data is m,n where
    start_pulse = min(find(data(:,1)>0)); % sync pulses
    end_pulse = max(find(data(:,1)>0)); % sync pulses
    
    if size(data, 2) > 1 %check we have enough channels
        if size(data, 2) > 2
            data = data(:,1:2); %only want channels 1 & 2.
        end
        data(start_pulse:end_pulse, 1) = 0.5; % revised per Mark's request.
        %(data(start_pulse:end_pulse, 1:2) +1) / 2; %  old peaks are now at 1, old 0 is now at 0.5
        % should be a sinusoid for the mic to pick up more easily
        
        sinusoid_length = length(data(start_pulse:end_pulse, 1));
        tone_frequency = 1000;
        sinusoid_data = sin(linspace(0, (sinusoid_length / SampleRate) * tone_frequency*2*pi, sinusoid_length));
        data(start_pulse:end_pulse, 1)  = sinusoid_data;
        
        %% Create analogue input object
        rec = audiorecorder(SampleRate, 16, 1);
        
        %         ai = analoginput('winsound');
        %         in_chan = addchannel(ai,[1]);
        %         set(ai,'SampleRate', SampleRate); %input sample rate crazyness
        %         set(ai,'SamplesPerTrigger', length(data)); %Number of samples to capture.
        %         set(ai,'TriggerType','Manual'); %Trigger type
        %         set(ai, 'TriggerRepeat', 0);
        %         true_ai_rate = get(ai,'SampleRate')
        
        %% Open the analog output device and channels
        player = audioplayer(data, SampleRate);
        
        %     ao = analogoutput('winsound');
        %     addchannel(ao, [1 2]);
        %     set(ao,'SampleRate',SampleRate); %set the sampling rate
        %     set(ao,'TriggerType','Manual'); %set the trigger type
        %     true_ao_rate = get(ao,'SampleRate')
        
        %% Put the data in the buffer, start the device, and trigger
        record(rec); %start recording
        playblocking(player); %play metronome
        stop(rec); %stop recording
        din = getaudiodata(rec); %get data;
        
        inputdata = din;
        %         putdata(ao,data)
        %
        %         start(ai)
        %         start(ao)
        %
        %         trigger(ao)
        %         trigger(ai)
        %
        %         inputdata = getdata(ai);
        %
        %         delete(ai)
        %         clear ai
        %
        %         delete(ao)
        %         clear ao
        
    else
        errordlg('Missing data for metronome output');
    end
    
    
    
end
